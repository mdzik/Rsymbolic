// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/symAlgebra.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// sAlg_fromString
sSymbol sAlg_fromString(Rcpp::String v);
static SEXP symAlgebra_sAlg_fromString_try(SEXP vSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< Rcpp::String >::type v(vSEXP );
        sSymbol __result = sAlg_fromString(v);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_fromString(SEXP vSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_fromString_try(vSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_fromDouble
sSymbol sAlg_fromDouble(double v);
static SEXP symAlgebra_sAlg_fromDouble_try(SEXP vSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< double >::type v(vSEXP );
        sSymbol __result = sAlg_fromDouble(v);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_fromDouble(SEXP vSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_fromDouble_try(vSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_fromInt
sSymbol sAlg_fromInt(int v);
static SEXP symAlgebra_sAlg_fromInt_try(SEXP vSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< int >::type v(vSEXP );
        sSymbol __result = sAlg_fromInt(v);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_fromInt(SEXP vSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_fromInt_try(vSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_plus
sSymbol sAlg_plus(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sAlg_plus_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sAlg_plus(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_plus(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_plus_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_minus
sSymbol sAlg_minus(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sAlg_minus_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sAlg_minus(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_minus(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_minus_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_times
sSymbol sAlg_times(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sAlg_times_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sAlg_times(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_times(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_times_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_divide
sSymbol sAlg_divide(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sAlg_divide_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sAlg_divide(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_divide(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_divide_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_power
sSymbol sAlg_power(const sSymbol& x, const sSymbol& y);
static SEXP symAlgebra_sAlg_power_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const sSymbol& >::type y(ySEXP );
        sSymbol __result = sAlg_power(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_power(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_power_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_equal
bool sAlg_equal(sSymbol& x, sSymbol& y);
static SEXP symAlgebra_sAlg_equal_try(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< sSymbol& >::type x(xSEXP );
        Rcpp::traits::input_parameter< sSymbol& >::type y(ySEXP );
        bool __result = sAlg_equal(x, y);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_equal(SEXP xSEXP, SEXP ySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_equal_try(xSEXP, ySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// sAlg_ToC
std::string sAlg_ToC(sSymbol& x);
static SEXP symAlgebra_sAlg_ToC_try(SEXP xSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< sSymbol& >::type x(xSEXP );
        std::string __result = sAlg_ToC(x);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP symAlgebra_sAlg_ToC(SEXP xSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(symAlgebra_sAlg_ToC_try(xSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}

// validate (ensure exported C++ functions exist before calling them)
static int symAlgebra_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("sSymbol(*sAlg_fromString)(Rcpp::String)");
        signatures.insert("sSymbol(*sAlg_fromDouble)(double)");
        signatures.insert("sSymbol(*sAlg_fromInt)(int)");
        signatures.insert("sSymbol(*sAlg_plus)(const sSymbol&,const sSymbol&)");
        signatures.insert("sSymbol(*sAlg_minus)(const sSymbol&,const sSymbol&)");
        signatures.insert("sSymbol(*sAlg_times)(const sSymbol&,const sSymbol&)");
        signatures.insert("sSymbol(*sAlg_divide)(const sSymbol&,const sSymbol&)");
        signatures.insert("sSymbol(*sAlg_power)(const sSymbol&,const sSymbol&)");
        signatures.insert("bool(*sAlg_equal)(sSymbol&,sSymbol&)");
        signatures.insert("std::string(*sAlg_ToC)(sSymbol&)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP symAlgebra_RcppExport_registerCCallable() { 
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_fromString", (DL_FUNC)symAlgebra_sAlg_fromString_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_fromDouble", (DL_FUNC)symAlgebra_sAlg_fromDouble_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_fromInt", (DL_FUNC)symAlgebra_sAlg_fromInt_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_plus", (DL_FUNC)symAlgebra_sAlg_plus_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_minus", (DL_FUNC)symAlgebra_sAlg_minus_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_times", (DL_FUNC)symAlgebra_sAlg_times_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_divide", (DL_FUNC)symAlgebra_sAlg_divide_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_power", (DL_FUNC)symAlgebra_sAlg_power_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_equal", (DL_FUNC)symAlgebra_sAlg_equal_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_sAlg_ToC", (DL_FUNC)symAlgebra_sAlg_ToC_try);
    R_RegisterCCallable("symAlgebra", "symAlgebra_RcppExport_validate", (DL_FUNC)symAlgebra_RcppExport_validate);
    return R_NilValue;
}
